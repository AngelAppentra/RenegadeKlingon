%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% Nombre del trabajo, 
% t�tulo,
% autores
% fechas, 
% comentarios, etc.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%\input miscomandos.tex % Comandos definidos por el autor

%\documentclass[a4paper,12pt]{book} 

%% Incluir los paquetes necesarios 
%\usepackage[latin1]{inputenc} % Caracteres con acentos. 
%\usepackage[spanish]{babel}
%\usepackage{latexsym} % Simbolos 
%\usepackage[pdftex=true,colorlinks=true,plainpages=false]{hyperref} % Soporte hipertexto
%\usepackage[pdftex]{graphicx} %Inclusión de gr�ficos PDFLaTeX
%\DeclareGraphicsExtensions{.png,.pdf,.jpg}
%\renewcommand{\baselinestretch}{1.5} %espacio entre lineas
%\sloppy % suaviza las reglas de ruptura de l�neas de LaTeX

% T�tulo, autor, fecha. 
\title{capitulo6} 
\author{Angel baltar Diaz}
\date{\Large Enero, 2010} 

%\begin{document} % Inicio del documento
%capitulo 1 introduccion
\chapter {Funciones destacadas del traductor de código}
\label{capitulo6}

En este capítulo explicaremos el traductor de código C secuencial a código C paralelo anotado con OpenACC, además de describir la infraestructura global del traductor, nos centraremos sobretodo en las partes objeto de este proyecto, el diseño e implementación de las directivas OpenACC a generar, así como de las transformaciones de código consideradas esenciales para el correcto funcionamiento del traductor.

\section{Infraestructura del traductor}
Para tener una visión general del traductor, vamos a explicar, a grandes rasgos, su infraestructura, la cual puede observarse en la figura \ref{fig:infraestructura}. Los diferentes módulos de la herramienta son los que se muestran a través de rectángulos en la figura; los cilindros representan el código, IR e información que entra en cada módulo o que sale de éste. La infraestructura consta por tanto de los seis módulos siguientes:

%figura infraestructura
\begin{figure}[t]
\begin{center}
\scalebox{0.37}{\includegraphics{includes/images/Diagrama_traductor.png}}
\caption{Esquema de la infraestructura general del traductor}
\label{fig:infraestructura}
\end{center}
\end{figure}
%

\begin{itemize}
\item \textbf{LLVM Passes} En esta parte de la herramienta se ejecutan varias pasadas estándar de LLVM (por ej. \textit{-mem2reg}) que transforman el código a su representación intermedia SSA.
\item \textbf{Filter} El filtro es el encargado de analizar el código en busca de características del código secuencial de entrada que no se soportan en los siguientes módulos para que éstas no pasen a fases posteriores y así evitar que se produzcan efectos colaterales no deseados debidos a sentencias, instrucciones, etc. no soportadas. Si algún código es filtrado se advierte mediante mensajes al usuario.
\item  \textbf{Normalization} Es el encargado de transformar el código a su representación intermedia en GSA y también de normalizar bucles y otras estructuras para que en fases posteriores sea más sencillo su tratamiento.
\item \textbf{KIR} (Glosario:{\ref{glosario}}) Es el módulo que se encarga de realizar todos los análisis del código para su paralelización (por ej. reducciones), el reconocimiento de núcleos computacionales, análisis de patrones de acceso a memoria y análisis de rángos [Arenaz et al. 2008b].
\item \textbf{Scheduler} Partiendo de la salida del módulo KIR, el Scheduler es el módulo encargado de generar estrategias de paralelización válidas para el código de entrada y decidir, en base a una métrica, cuál es la mejor. Posteriormente, es la encargada de crear los \textit{CodeTransforms}. Toda la infraestructura de los \textit{CodeTransforms} es la que se encarga de la generación de directivas correspondientes dependiendo del lenguaje que se desee (OpenMP, OpenACC..). Esta una de las aportaciones de este proyecto.
\item \textbf{Backend} En base a todos los análisis anteriores, es el módulo encargado de la reconstrucción del código original gracias a las representaciones intermedias (IR, SSA, GSA) y a producir el código paralelo de salida (en lenguaje C) anotada con directivas en un lenguaje como OpenMP u OpenACC.
\end{itemize}

Las contribuciones de este Proyecto de Fin de Carrera a los módulos anteriores son:
\begin{itemize}
\item Con respecto a los \textit{CodeTransforms} , es tarea de este proyecto el diseño e implementación de esta jerarquía de clases que ofrece una API a la fase de Scheduler y Backend, integrándose en este punto a la infraestructura de compilación presentada.
\item Algunos de los CodeTransforms anteriormente citados representarán las transformaciones de código clásicas sobre bucles (desenrrollamiento,intercambio y fisión) que ya hemos introducido anteriormente en esta memoria. Es tarea de este proyecto dar la implementación adecuada sobre la IR de LLVM a estas transformaciones de código.
\end{itemize}

\section{Representación objetual de transformaciones de código y directivas OpenACC}

Antes de entrar en detalles concretos de implementación, es importante hablar sobre la representación objetual de las directivas de OpenACC.
Se ha diseñado e implementado una jerarquía de directivas que se puede observar en el diagrama UML de la figura ~\ref{fig:TransformsGeneratorsUML} que se muestra a continuación. Esta jerarquía de clases es fruto del trabajo colaborativo en el seno de un equipo de producción de la empresa. El diseño se integra con los distintos módulos del traductor.

A grandes rasgos, el diseño consta de dos partes que definen un patrón Factoría (\textit{Factory Method}). Puede verse este patrón en el diagrama de la figura ~\ref{fig:TransformsGeneratorsUML} en él que las dos jerarquías se relacionan mediante dependencias de creación. ~\textit{OpenAccTransform} (Jerarquía Creadora) es la encargada de crear los objetos de la jerarquía de \textit{CodeGenerators}, en concreto con la jerarquía de OpenAccDir. Este patrón permite independizar al \textit{Scheduler} de cualquier \textit{CodeGenerator}.

El \textit{Scheduler} solo trabajará con \textit{CodeTransforms}. Además esto tiene una importante ventaja, el Scheduler puede evaluar cuantas estrategias de paralelización necesite creando múltiples composiciones de \textit{CodeTransforms} (Cada composición representa una estrategia concreta), pero los \textit{CodeGenerators} no serán creados hasta que se llame al método plantilla apply sobre la estrategia de paralelización finalmente elegida.

Esto supone un importante ahorro de memoria haciendo posible la evaluación de múltiples estrategias como acabamos de explicar. En el diagrama presentado no se ve ningún caso, pero pensemos que es posible que un \textit{CodeTransform} genere más de un \textit{CodeGenerator}, este caso podría darse fácilmente si extendemos las transformaciones de código contemplando casos en los que cierta construcción de código se realiza empleando varias directivas, el \textit{CodeTransform} resultante generaría varios \textit{CodeGenerators}, al menos uno por directiva.


\begin{landscape}
\begin{figure}[t]
\includegraphics[width=0.93\linewidth]{includes/images/CodeTransformsGenerators.png}
\thispagestyle{empty}
\caption{UML de las directivas y transformaciones de código}
\label{fig:TransformsGeneratorsUML}
\end{figure}
\end{landscape}

Comencemos por explicar la jerarquía de la clase \textit{CodeTransform}, esta jerarquía representa de modo genérico cualquier transformación susceptible de ser aplicada a un código dado, para entender esta jerarquía de modo global analicemos sus operaciones más importantes:

\begin{itemize}

\item Método \textit{SelfCopy}: Realiza una copia del objeto actual sobre un objeto pasado, esta operación tiene visibilidad protegida, se emplea para implementar la operación de clonado.

\item Método \textit{Clone}: Tiene como objetivo implementar el patrón de diseño Prototype, este patrón implementa en cada objeto un metodo clone que devuelve una copia del objeto, de este modo pueden crearse objetos nuevos a imagen y semejanza de prototipos establecidos. Este patrón se implementa en todos los objetos del diagrama presentado, ya que puede ser muy útil en el planificador (Scheduler) para realizar la creación de objetos CodeTransform.

\item Método \textit{Evaluate}: Esta operación carece de implementación en la versión actual, no obstante  es útil considerarla para permitir una funcionalidad futura. Esta funcionalidad sería que cada transformación de código pueda evaluar su propio beneficio de aplicación sobre un código dado, de este modo podría implementarse una métrica de rendimiento de un conjunto de transformaciones dado, lo que sería de gran utilidad para la fase de Scheduler.

\item Método \textit{Apply}: Esta operación implementa un patrón plantilla o template method. Este patrón se basa en que una operación puede definirse de forma genérica en la superclase pero empleando métodos que serán redefinidos por cada subclase. De esta manera todas las clases pueden compartir el código de un algoritmo común definido en base a operaciones genéricas, y cada subclase tan solo redefinirá aquellas operaciones genéricas cruciales para su correcto funcionamiento. En nuestro caso el método apply se apoya en las operaciones concretas create y transform que definimos a continuación.

\item Método \textit{create}: Parte del patrón plantilla implementado, el método create tiene como objetivo crear los generadores de código (\textit{CodeGenerators}) necesarios para aplicar correctamente la transformación de código, trataremos los CodeGenerators más adelante.
En general podemos decir que transformaciones de código asociadas a generación de directivas han de crear CodeGenerators a través de este método create, sin embargo transformaciones de código que realmente no generan nada nuevo, solo modifican código ya existente no implementarán este método o le darán una implementación vacía.

\item Método \textit{transform}: Parte del patrón plantilla implementado, el método transform tiene por objetivo aplicar transformaciones de código sobre código ya existente y sin generar nada nuevo. Por el motivo anterior este método tendra implementación vacía en los CodeTransforms dedicados a generación de directivas y por la contra a de tener una implementación específica en aquellas transformaciones de código que se dedican a cambiar código previamente existente como por ejemplo en la transformación LoopUnrolling.

\end{itemize}

Vistas las operaciones más importantes de la jerarquía de transformaciones de código ahora bajaremos más en la jerarquía para comentar las subclases. Como ya adelantábamos en la explicación del patron plantilla empleado existen dos grandes grupos de transformaciones, las que generan algo nuevo, y las que simplemente modifican código existente, comencemos por las que transforman código existente.

\section{Transformaciones de código}

En el diagrama podemos ver las transformaciones de código que no generan directivas heredando de la superclase \textit{CodeTransform} justo debajo de ella y hacia la parte izquierda, ahora presentaremos brevemente cada una de estas transformaciones.

\subsection{Fision de bucles}

Implementada en la clase \textit{LoopFisionTransform} la fisión de bucles aplica sobre un bucle dado una división del mismo en N bucles en los que el cuerpo de cada bucle contiene una fracción del cuerpo del bucle original.Veamos un ejemplo muy simple de esta transformación en la figura ~\ref{FIG:FisionExample} :

\begin{figure}[t]
\begin{lstlisting}
for(i=0;i<100;i++)
{
	a[i]+=b[i];
	foo(a[i]);
}

//fisioned loop:

for(i=0;i<100;i++)
{
	a[i]+=b[i];
}

for(i=0;i<100;i++)
{
	foo(&a[i]);
}
\end{lstlisting}
\caption{Ejemplo de fisión de bucle}
\label{FIG:FisionExample}
\end{figure}

El primer bucle contenía dos operaciones, la primera de ellas es paralelizable. Asumamos que la segunda no lo es. Teniendo el código original no podríamos paralelizar nada ya que una de sus dos operaciones internas no puede paralelizarse. Sin embargo aplicando fisión podríamos paralelizar el primero de los bucles resultado. De este modo aunque siga quedándonos una parte no paralela habremos ganado tiempo.

Finalmente destacar que la fisión de bucles es un recurso habitual en la programación de GPUs pues nos permite simplificar bucles con flujos de control complejos y/o dependencias que impidan la paralelización del bucle.

\subsection{Desenrrollamiento de bucles}

Implementada en la clase \textit{LoopUnrollingTransform} el desenrrollamiento de bucles aplica sobre un bucle un clonado del cuerpo del bucle N veces con lo que las iteraciones también se reducen en un factor N. Si el número de iteraciones del bucle es divisible por el factor N, el desenrollamiento es simple ya que los números encajan a la perfección, si no lo es, es necesario insertar un preámbulo y un postambulo de código antes de entrar y despues de salir del bucle respectivamente, para tratar las iteraciones sobrantes. Esta transformación de código comprueba que el factor de desenrollamiento N divide perfectamente al número de iteraciones para evitar el preámbulo y el postambulo, de lo contrario no se aplica.
Veamos en la figura ~\ref{FIG:UnrollExample} un ejemplo de aplicación de unrolling:

\begin{figure}[t]
\begin{lstlisting}
for(i=0;i<100;i++)
{
	a[i]+=b[i];
	foo(&a[i]);
}

//unrolled loop

for(i=0;i<100;i+=2)
{
	a[i]+=b[i];
	foo(&a[i]);

	a[i+1]+=b[i+1];
	foo(&a[i+1]);
}
\end{lstlisting}
\caption{Ejemplo de desenrollamiento de bucle}
\label{FIG:UnrollExample}
\end{figure}

Comentemos ahora brevemente para que podemos usar el unrolling: Imaginemos un bucle que sabemos no desaparecerá en GPU, en este caso puede ser beneficioso un unrolling ya que sabemos que el bucle llegará a la GPU si fuese completamente independiente (cláusula independent) el bucle podría desaparecer al repartirse entre múltiples threads GPU, pero al no serlo el bucle se mantendrá. Manteniendose el bucle puede resultar beneficioso desenrollarlo. Pensemos que al fin y al cabo el bucle introduce instrucciones artificiales que realmente no realizan computación útil. Hablamos de las instrucciones de comparación de la cabecera del bucle, el incremento del índice etc. Desenrollando el bucle lo que logramos es que la proporción de instrucciones artificiales de gestión del bucle se reduzcan respecto a las instrucciones de computación útil que pertenecen al cuerpo del bucle, ya que este cuerpo en un bucle desenrollado es más grande y el número de iteraciones (numero de ejecuciones de instrucciones de gestión del bucle) es menor.
La desventaja del desenrollamiento de bucles es que, evidentemente, si repetimos una y otra vez cuerpo de bucle, aumentamos el tamaño del código generado.

Finalmente destacar que el desenrrollamiento de bucles es un recurso habitual en la programación de GPUs pues permite al compilador de la GPU realizar más optimizaciones para mejorar el rendimiento.

\subsection{Intercambio de bucles}
El intercambio de bucles implementado en la clase \textit{LoopInterchangeTransform } tal y como se ha implementado esta pensado para intercambiar el orden de dos bucles en anidamiento perfecto, esto es útil cuando el orden de los bucles y el patrón de acceso a posiciones de memoria de un array estan organizados de tal manera que la localidad de memoria en CPU o la coalescencia en GPU no son explotadas con la consecuente pérdida de rendimiento, veamos un ejemplo en la figura ~\ref{FIG:InterchangeExample}:

\begin{figure}[t]
\begin{lstlisting}
for(j=0;j<N;j++)
{
	for(i=0;i<M;i++)
	{
		a[i][j]=b[i][j];
	}
}

//loop interchange:

for(i=0;i<M;j++)
{
	for(j=0;j<N;i++)
	{
		a[i][j]=b[i][j];
	}
}
\end{lstlisting}
\caption{Ejemplo de intercambio de bucles}
\label{FIG:InterchangeExample}
\end{figure}

Ya hemos comentado la importancia en GPU de explotar la localidad de memoria, la coalescencia, de modo que esta transformación de código puede ser muy importante si el código de entrada no cumple las características necesarias para hacerlo.

Finalmente destacar que el intercambio de bucles es un recurso habitual en la programación de GPUs ya que permite mejorar la localidad de acceso a memoria de los programas, con el consiguiente beneficio en el rendimiento.

\subsection{Privatización de variables}

En la clase \textit{PrivatizeTransform} se implementa una transformación que tiene como objetivo privatizar una variable. Esto es útil por ejemplo en una operación de reducción en un bucle, el objetivo de la privatización es que cada hilo de la paralelización posea su propia variable de reducción realizando una reducción parcial, en otra fase después de la ejecución paralela ha de realizarse una reducción global para obtener el resultado final correcto sobre la variable compartida entre todos los threads.

De este modo esta transformación lo único que hace es crear una variable nueva privada a partir de la variable compartida existente en el código secuencial. Puede parecer que esta no es una transformación de código sino que genera algo nuevo, sin embargo sí lo es, ya que la variable privada nueva se inserta en la IR del compilador modificando directamente el código de entrada, no se genera ninguna representación en memoria nueva para la nueva variable salvo las estrictamente necesarias para insertarla en la IR LLVM.

\subsection{Operaciones de reducción}

Esta transformación de código implementada en la clase \textit{LoopReductionReplaceTransform} está íntimamente ligada a la anterior, en un caso como el expuesto en el punto anterior además de la creación de la variable privada han de remplazarse los usos de la variable compartida en el bucle por la privada, de este modo garantizamos que cada hilo realiza los cálculos sobre su propia variable privada. 


Como hemos visto se implementan transformaciones sobre bucles, y transformaciones para la privatización de variables. En este último caso es necesario decir que OpenACC cuenta con operaciones de reducción propias que se pueden indicar en directivas sin tener que implementarlas directamente. Sin embargo estas transformaciones son útiles cuando nos encontramos una operación de reducción que no es soportada por el estándar OpenACC directamente en sus directivas. En secciones posteriores se explicará de modo más detallado la implementación específica de las transformaciones más importantes.

Es importante también hacer notar que durante el diseño se evaluó la posibilidad de generalizar parte de las transformaciones de código en una nueva clase intermedia, ya que todas las transformaciones sobre bucles empleaban los objetos Loop y LoopInfo para implementar transformaciones sobre bucles. Esto finalmente no se llevó a cabo porque se considera que las transformaciones de código pueden crecer, ser muy variadas y necesitar unas hacer uso de unos objetos y otras de otros, por tanto se decidió no crear clases intermedias para dar esta libertad a futuras implementaciones.

\section{Directivas de compilacion OpenACC}

Vistas las transformaciones de código que realizan precisamente una transformación del código de entrada, pasamos ahora a ver aquellas transformaciones que tienen por objeto la generación de directivas OpenACC y por tanto crean nuevos objetos en memoria para representar estas directivas. Estas transformaciones de código de generación de directivas de las que hablamos extienden de la clase OpenAccTransform, que es subclase a su vez de \textit{CodeDirTransform}.

\textit{CodeDirTransform} representa cualquier transformación de código cuyo objetivo sea generar una directiva o incluso, de manera más general, generar una nueva porción de código no existente en el código de partida, por esta razón \textit{OpenAccTransform} hereda de ella, representa la generación de directivas en este caso directivas OpenACC. Nótese que gracias a este diseño la ampliación del traductor para generar nuevos tipos de directivas es posible, implementando nuevas jerarquías de clases similares a la jerarquía de \textit{OpenAccTransform} que en este proyecto se presenta.

El corazón de cualquier objeto de generación de directivas ha de ser el método create, que como veíamos anteriormente forma parte del patrón plantilla implementado y tiene por objetivo generar los \textit{CodeGenerators} que correspondan en cada caso.


Introducidas de este modo las transformaciones que nos ayudarán a generar las directivas hagamos ahora un repaso por las subclases hoja que finalmente generarán directivas específicas.

\subsection{La directiva Data}

La directiva Data se implementa en la clase \textit{OaccDataTransform} que Representa la generación de una directiva data, ésta contiene varias listas internas, cada una de las listas almacena respectivamente, una lista de variables a crear (cláusula CREATE) , variables a copiar de la CPU a la GPU y viceversa una vez realizado el cálculo (cláusula COPY) etc. El establecimiento de estas listas con las variables adecuadas es responsabilidad del planificador (Scheduler) que cuenta con métodos en la clase OaccDataTransform a los que llamar para establecerlas. El método create de esta clase debe crear un objeto OpenAccData que representa la directiva final generada.

\subsection{La directiva Kernels}
La directiva Kernels se implementa en la clase \textit{OaccKernelsTransform} que Representa la generación de una directiva Kernels, su método create crea un nuevo objeto OpenAccKernels creando así la directiva final a imprimir en el código.

\subsection{La directiva Loop}
La directiva Loop se implementa en la clase \textit{OaccLoopTransform} que Representa la generación de una directiva Loop, mediante métodos puede controlarse la generación de las cláusulas de esta directiva (independent, gang y workers). Su método create crea un nuevo objeto OpenAccLoop creando la directiva Loop final.

\subsection{Composición de directivas}
El estandar OpenACC permite que algunas de sus directivas se combinen, en la clase \textit{OaccCompositeTransform} las directivas anteriormente presentadas pueden componerse de varias maneras, tal y como permite el estándar OpenAcc componer algunas directivas, por ejemplo puede usarse "\#pragma acc kernels loop" (composición de kernels y loop), las composiciones no permitidas están controladas por la implementación.

\section{Implementación detallada de una directiva OpenACC}

Con todo lo anterior hemos visto de modo general como podemos generar directivas y transformaciones en el código, pero aun no hemos expuesto la representación de una directiva finalmente generada, de esta tarea se encarga la jerarquía de los \textit{CodeGenerators}. Para entender como esta jerarquía es capaz de generar las directivas finalmente en el código haremos un breve repaso por los métodos fundamentales de la misma:

\begin{itemize}

\item Método \textit{toCode}: Este método devuelve una cadena que representa la directiva tal y como debe aparecer generada en el código de salida.

\item Método \textit{isCodeGeneratorOpenInst}: Este método recibe una instrucción de la IR de LLVM y devuelve true si dicha instrucción es la primera a la que la directiva se aplica, es decir la directiva ha de insertarse en el código justo antes de esa instrucción.

\item Método \textit{isCodeGeneratorCloseInst}: Este método recibe una instrucción de la IR de LLVM y devuelve true si esa instrucción es la primera a la que la directiva ya no debe aplicarse, es decir la llave de la directiva si la hubiera debe cerrarse justo antes de esa instrucción.

\item Método \textit{hasBrace}: Este método devuelve true en las directivas en las que deben abrirse y cerrarse llaves ( "\{\}") y false en las que no.

\end{itemize}

Estas son las operaciones fundamentales que hacen que una vez generadas las directivas su generación en el código sea trivial.

A continuación se presenta la implementación completa de una directiva desde que un \textit{CodeTransform} la crea hasta que pueda ser impresa finalmente en el código habiendo sido llamada a imprimirse por el Backend del compilador, todas las directivas se implementan de manera similar, por tanto presentando la implementación de una de ellas confiamos en que el lector comprenda el diseño e implementación globales.

Presentamos ahora la implementación de la directiva OpenAcc Loop para que el lector comprenda claramente como se realiza la implementación de una directiva concreta en el marco del diseño presentado en la sección anterior.

Como ya explicamos, la generación de directivas tiene dos partes fundamentales, el objeto encargado de la generación del objeto directiva (Patrón factoría) y el objeto directiva en si mismo. Para la directiva OpenAcc Loop el generador se implementa en la clase \textit{OaccLoopTransform}. Veamos ahora los métodos más importantes de esta clase y la implementación en pseudocódigo del método create que finalmente genera la directiva:

\begin{itemize}

\item \textit{setWorker}: Establece la cláusula worker de la directiva Loop a ser generada, ha de comprobarse que dicha cláusula worker no entra en conflicto con otras cláusulas ya establecidas

\item \textit{setGang}: Establece la cláusula gang de la directiva Loop a ser generada, ha de comprobarse que la cláusula no entra en conflicto con otras cláusulas ya establecidas.

\item \textit{setIndependent}: Establece la cláusula Independent de la directiva Loop a ser generada, ha de comprobarse que la cláusula no entra en conflicto con otras cláusulas ya establecidas.

\item \textit{selfCopy}: Realiza una copia de si mismo sobre un objeto OaccLoopTransform pasado. Simplemente se copian todos los atributos (se realiza una copia en profundidad) .

\item \textit{Clone}: Se vale del método anterior para implementar la operación de clonado.

\item \textit{Create}: Es el método más importante de cualquier \textit{CodeTransform} que tenga como cometido generar directivas, ya que en este método es donde éstas se crean, presentamos en la figura ~\ref{FIG:LoopCreation} su pseudo-código para la clase \textit{OaccLoopTransform}:

\begin{figure}[t]
\begin{lstlisting}

vector<CodeGenerator*> OaccLoopTransform::create()
{
	vector<CodeGenerator*> vectorCodeGen;

	OpenAccLoop *loop=new OpenAccLoop();

	loop->setFirstInst(this->getFirstInst());
	loop->setPostLastInst(this->getPostLastInst());

	if(this->_gangPresent)
		loop->setGang(this->_gang);

	if(this->_independent)
		loop->setIndependent();
	
	if(this->_workerPresent)
		loop->setWorker(this->_worker);

	for(j=0;j<ListasReduccion;j++)
	{
		for(k=0;k<Size(ListaReduccion(j));k++)
		{
			loop->addReducctionVar(ListaReduccion(j)[k]);
		}
	}
	vectorCodeGen.push(loop);
	return vectorCodeGen;
}

\end{lstlisting}
\caption{Creación de la directiva Loop}
\label{FIG:LoopCreation}
\end{figure}

En el código anterior lo primero que se hace es declarar la lista de generadores de código que se devolverá, se crea un objeto directiva loop, se le establecen los atributos de sus cláusulas copiándolos de los atributos propios del \textit{CodeTransform} (this). Nótese que la directiva Loop tiene varias listas de variables de reducción, una lista por operación de reducción soportada (mínimos, máximos, etc), que también se establecen.

En general esta es la labor del método \textit{create} de los objetos generadores de directivas, generar su directiva o directivas correspondientes, establecer las cláusulas de las directivas y devolver las directivas creadas.


\end{itemize}


Visto el generador de la directiva \textit{OpenAccLoop}, veamos ahora esta directiva \textit{OpenAccLoop}. Como ya veíamos en el \textit{CodeTransform} que la genera existen métodos \textit{set} para poder establecer las cláusulas de la directiva. Además de estos métodos set, para cualquier \textit{CodeGenerator}, en particular cualquier directiva, el método más importante es el método \textit{toCode} que genera el string de código que corresponde a la directiva completamente generada en el código de salida, veamos en pseudo-código la implementación de este método para la directiva Loop en la figura ~\ref{FIG:LoopToCode}:
\newpage

\begin{figure}[tph]
\begin{lstlisting}
// Prints the Complete directive
string OpenAccLoop::toCode(){
	return OpenAccDir::toString()+this->toString();
}
//Prints this directive
string OpenAccLoop::toString(){
	static const string _nameLists[OpenAccLoop::NLISTS]= {"max","min"};
	string ret="loop ";
	if(_independent)
		ret+="independent ";
	if(_gangPresent){
		ret+="gang";
		if(_gang)
			ret+="("+_gang+")";
		ret+=" ";
	}
	if(_workerPresent){
		ret+="worker";
		if(_worker)
			ret+="("+_worker+")";
		ret+=" ";
	}
	Value *var;
	for(k=0;k<OpenAccLoop::NLISTS;k++){
		if(!_varLists[k].empty())
			ret+="reduction("+_nameLists[k]+":";
		for(j=0;j<_varLists[k].size();j++){
			var=_varLists[k][j];
			ret+=llvmHelper::getNameClean(var);
			if(j+1<_varLists[k].size())
				ret+=",";
		}
		if(!_varLists[k].empty())
			ret+=") ";
	}
	return ret;
}

\end{lstlisting}
\caption{Generación del código final de la directiva OpenAcc Loop}
\label{FIG:LoopToCode}
\end{figure}


Como podemos comprobar en la línea 3 el método \textit{toCode} no hace más que llamar al \textit{toString} de la clase \textit{OpenAccDir} y a su propio \textit{toString}, el \textit{toString} de la clase \textit{OpenAccDir} no hace más que imprimir el \#pragma acc, encabezado que precede a cualquier directiva OpenAcc, por lo que puede reutilizarse en todas estas directivas. De este modo quien realmente realiza el trabajo de la impresión de la directiva Loop es el método \textit{toString} de dicha directiva.

El método \textit{toString} comienza declarando la cadena ret en la línea 8, esta cadena es la que será devuelta, de las líneas 9 a 22 lo único que se hace es ir concatenando a la cadena las cláusulas que estén presentes en la directiva, nótese que en las cáusulas gang y worker pueden estar presentes tan solo las palabras gang o worker o también se puede indicar el número de ellos respectivamente.

Recordemos además que la consistencia de las cláusulas se comprueba en los métodos seters de las mismas, en ellos no se permite establecer cláusulas no compatibles entre sí, por tanto en este método \textit{toString} se asume que las cláusulas establecidas son correctas y no se realizan comprobaciones.

A partir de la linea 22 lo que se hace es la impresión de las variables de reducción si es que la directiva las posee, se recorren todas las listas de variables de reducción, en este pseudo-código son 2 (mínimo y máximo), y para cada una se imprime reduction (nombreOperacionReduccion: lista variables reducción separadas por comas). Para esto simplemente se recorre la lista de variables y se imprime cada nombre de variable. El nombre de cada variable se obtiene mediante el método \textit{getnameclean} del espacio de nombres \textit{llvmHelper}, este espacio de nombres define funciones de acceso al API LLVM proporcionando una capa de independencia de la misma.

La implementación de la conversión de las directivas a cadenas de texto directamente insertables en código es siempre igual, imprimir el \#pragma acc e imprimir la directiva, que también es siempre igual, imprimir el nombre de la directiva y sus cláusulas que se obtienen directamente a partir de atributos del objeto que representa a la directiva.

Presentada de este modo la implementación de la directiva \textit{OpenAccLoop} desde su \textit{CodeTransform} hasta su \textit{CodeGenerator} que finalmente es el encargado de generarla sobre el código confiamos en que el lector comprenda el diseño global de las directivas.

En una perspectiva más global lo que ocurre en el compilador para generar las directivas es, llegados a la fase de Scheduler, el \textit{Scheduler} decide una estrategia de paralelización que involucra a varias transformaciones de código (CodeTransforms), el \textit{Scheduler} decide aplicar (\textit{Apply}) dichas \textit{CodeTransforms}, algunas de las cuales generaran \textit{CodeGenerators} que representan directivas, y otras habrán modificado el propio código de entrada.

Finalizada la fase de \textit{Scheduler} lo que tenemos pues es una serie de transformaciones de código que ya habrán modificado código de entrada (Método \textit{Transform}) y una lista de \textit{CodeGenerators} para generar código nuevo (creados mediante el método \textit{create}). Dicha lista llega al backend del traductor quien finalmente emplea el método toCode de los \textit{CodeGenerators} para generar el código nuevo, en nuestro caso directivas.

\section{Implementación detallada de transformaciones de código}

En esta sección explicaremos la implementación de las transformaciones de código consideradas en este proyecto, éstas son las transformaciones clásicas que se aplican a bucles y que ya hemos presentado, son Loop Unrolling, Loop Interchange y Loop Fision.

Si consideramos estas tres transformaciones de código y las pensamos detenidamente, nos daremos cuenta de que en las tres lo que hemos de modificar de la representación intermedia (\textit{IR}) del compilador LLVM son las estructuras CFG (\textit{Control Flow Graph}) y ASTs(\textit{Abstract Syntax tree}).
Hemos de modificar el CFG cambiando destinos de salto entre bloques básicos, etc, para modificar el código según nos convenga para lograr la transformación perseguida. En otros casos hemos de modificar, crear o copiar instrucciones modificando los ASTs etc.
Ahora estudiaremos detalladamente una por una las tres transformaciones y presentaremos sus respectivas implementaciones en pseudo-código.

\subsection{Implementación del desenrrollamiento de bucles}

En el desenrollamiento de bucles (Loop Unrolling) lo que hemos de realizar son sucesivas copias del cuerpo del bucle, teniendo en cuenta que cada una de esas copias ha de trabajar con un valor del índice del bucle previamente incrementado. Además hemos de modificar el incremento final del indice del bucle para que el paso del incremento sea proporcional al factor de desenrollamiento.

Recapitulando, lo que debemos hacer, en términos de IR LLVM, es copiar los bloques básicos del cuerpo del bucle junto con sus instrucciones N veces, asegurar que cada cuerpo del bucle trabaja con un índice de bucle correcto y modificar el paso del incremento del índice del bucle.

El \textit{loop Unrolling} está implementado en el \textit{CodeTransform} llamado \textit{LoopUnrollingTransform}, ahora presentaremos los métodos de esta clase que permiten la aplicación de la transformación.

Lo primero que debemos hacer para aplicar un unrolling es verificar que el bucle sobre el que lo vamos a aplicar reúne las condiciones de aplicación requeridas en este proyecto fin de carrera. Eso se hace mediante el método \textit{ApplyUnrollLoop\_check\_pre\_requisites} que presentamos en la figura ~\ref{FIG:LoopUnrollRequisites}:


\begin{figure}[t]
\begin{lstlisting}

/**
 * checks the necesary conditions for perform the loop unrolling
 */
bool LoopUnrollingTransform::ApplyUnrollLoop_check_pre_requisites()
{
	if(this->_L->getSubLoops().size()!=0)
	{
		return false;
	}

	Value * count=llvmHelper::getLoopCount(this->_L);
	ConstantInt *limit=dyn_cast<ConstantInt>(count);
	if(!limit)
	{
		return false;
	}

	unsigned lim=llvmHelper::getValueConstantInt(limit);

	if((lim<=this->_unroll_factor)||(limç\%çthis->_unroll_factor))
	{
		return false;
	}
	return true;
}

\end{lstlisting}
\caption{Validación del cumplimiento de los requisitos para aplicar desenrollamiento de bucles}
\label{FIG:LoopUnrollRequisites}
\end{figure}

El bucle a desenrollar se almacena en un atributo llamado \textit{\_L} y el factor de desenrollamiento en otro llamado \textit{\_unrooll\_factor}. Lo primero que el método de comprobación de requisitos hace es comprobar que no existen bucles dentro del bucle a desenrollar, se recupera la lista de subloops de \textit{\_L} y se comprueba que tenga tamaño cero.A continuación de las líneas 12 a 19 se hacen las operaciones necesarias para recuperar el número de iteraciones del bucle, obsérvese que en la línea 14 se comprueba que el número de iteraciones pudo ser determinado, si es indeterminado no se permite el unrolling.Conocido el número de iteraciones, si éste es menor que el factor de desenrollamiento o no es divisible por él, entonces no se permite la transformación.En cualquier otro caso la transformación puede ser llevada a cabo sin problemas.

Ahora presentaremos el pseudo-código que permite el desenrollamiento del bucle. Este código será presentado y explicado en sucesivas figuras ya que se trata de un código simple pero largo y con múltiples partes bien diferenciadas que cumplen cada una diferentes objetivos.

El unrolling se implementa en el método transform de la clase \textit{LoopUnrollingTransform}, comienza con el siguiente código presentado en la figura ~\ref{FIG:LoopUnrollCheck}:

\begin{figure}[t]
\begin{lstlisting}
/// Transforms the code performing a loop unrolling transform
void LoopUnrollingTransform::transform()
{
	if(!ApplyUnrollLoop_check_pre_requisites()){
		llvmHelper::xark_unreachable("LoopUnrollingTransform::transform()"
					     "Loop unrolling pre-requisites fail");
	}
	...
\end{lstlisting}
\caption{Desenrollamiento de bucles, comprobación de requisitos}
\label{FIG:LoopUnrollCheck}
\end{figure}

Al inicio de la operación \textit{transform} de unrolling simplemente se usa el método de comprobación de requisitos comentado anteriormente. Si los requisitos no se cumplen se advierte mediante un mensaje de error.

En la siguiente sección de código de la figura ~\ref{FIG:LoopUnrollInit} se inicializan y declaran variables con el fin de tener todo dispuesto para la aplicación del desenrollamiento.

\begin{figure}[tph]
\begin{lstlisting}
BasicBlock *hard_work=llvmHelper::getLoopFirstWork(_L,_LI);
BasicBlock *end_hard_work=
		llvmHelper::getPrevNode(llvmHelper::getLoopLatch(_L));
BasicBlock *new_hard_work;
Instruction *add_inc=llvmHelper::getAritmeticLoopIncrementInst(_L);
Value *loop_index=llvmHelper::getRealIndexPhiInst(_L);
ConstantInt *constant_inc;
unsigned int operand_cte=1;
if(dyn_cast<ConstantInt>(llvmHelper::getOperand(add_inc,1))){
	operand_cte=1;
	constant_inc=dyn_cast<ConstantInt>(llvmHelper::getOperand(add_inc,1));
}
else{
	operand_cte=0;
	constant_inc=dyn_cast<ConstantInt>(llvmHelper::getOperand(add_inc,0));
}
//we get an iterator pointing at the first work of the loop
iplist<BasicBlock>::iterator first_work;
for(first_work=hard_work->getParent()->getBasicBlockList().begin();
	first_work!=hard_work;first_work++);
//we get an iterator pointing at the last work of the loop
iplist<BasicBlock>::iterator last_work;
for(last_work=first_work;
	last_work!=end_hard_work;last_work++);
//we get another iterator pointing at the last work of the loop
iplist<BasicBlock>::iterator last_loop=last_work;
map<BasicBlock*,BasicBlock*> remap_map;
iplist<BasicBlock>::iterator iterator_mark_init=last_loop;
//now we must copy the work of the loop (unrroll_factor-1) times
//this way we get the loop unrolled
BasicBlock *ant=&*last_work;
Instruction *add_ant=0,*add,*I;
unsigned i,u;
BasicBlock *act;
BranchInst *Term;
BasicBlock *successor;
BasicBlock *operand;
...
\end{lstlisting}
\caption{Desenrollamiento de bucles, inicialización de variables}
\label{FIG:LoopUnrollInit}
\end{figure}

Para explicar esta inicialización de variables presentada, iremos variable a variable explicando su función. La primera que encontramos es el bloque básico \textit{hard\_work} que representa el primer bloque de trabajo del bucle, y la variable \textit{end\_hard\_work} que representa el último que se sitúa justo antes del bloque \textit{latch} del bucle (\textit{latch} es el bloque donde se incrementa el índice del bucle).Se obtiene también la instrucción de incremento del bucle sobre la variable \textit{add\_inc}. Aunque esta variable tenga este nombre, el incremento no solo puede ser mediante suma, aunque esto es lo habitual. A partir de la instrucción de incremento, se obtiene el operando paso del bucle, número en el que se incrementa el índice en cada iteración (se comprueba si el paso está en el operando cero o uno de la instrucción de incremento).A continuación se declaran una serie de variables e inicializan algunos iteradores apuntando a bloques básicos que nos serán útiles en la siguiente fase del algoritmo. Obsérvese que se inicializan los iteradores a las posiciones deseadas iterando sobre la lista de bloques y parando dicha iteración cuando es conveniente según la condición de parada de los bucles de los iteradores.

Veamos ahora en la figura ~\ref{FIG:LoopUnrollClone} la zona del código de la transformación donde se clona una y otra vez el cuerpo del bucle para lograr la transformación de desenrollamiento:

\begin{figure}[tph]
\begin{lstlisting}
for(i=1;i<_unroll_factor;i++){
	//LETS DO A NEW COPY OF THE WORK USING AN INCREMENTED INDEX
	add=add_inc->clone();
	llvm::Constant * to_add=(llvm::Constant)(i*constant_inc);
	llvmHelper::setNumOperand(add,operand_cte,to_add);
	for(iplist<BasicBlock>::iterator it=first_work;
			it<=last_work;it++){
		new_hard_work=llvmHelper::cloneBB(it);
		if((it==first_work)){//linking the unrollings
			llvmHelper::setSuccessor(llvmHelper::getTerminator(ant),
					0,new_hard_work);
		}
		remap_map.insert(pair<BasicBlock*,BasicBlock*>(it,new_hard_work));
		_L->getHeader()->getParent()->getBasicBlockList().
					insertAfter(last_loop,new_hard_work);
		//replacing the index for the last unroll add
		for(BasicBlock::iterator Iti=new_hard_work->begin(),
			Eti=new_hard_work->end();Iti!=Eti;Iti++){
			I=Iti;
			for(u=0;u<llvmHelper::getNumOperands(I);u++){
				if(llvmHelper::getNumOperand(I,u)==loop_index){
					llvmHelper::setNumOperand(I,u,add);
				}
			}
		}
		//insert the add to the first work block for this unroll
		if(it==first_work){
			new_hard_work->getInstList().
				insertAfter(new_hard_work->begin(),add);
		}
		last_loop++;
		ant=new_hard_work;
	}
	add_ant=add;
...
\end{lstlisting}
\caption{Desenrollamiento de bucles, Clonado del cuerpo del bucle}
\label{FIG:LoopUnrollClone}
\end{figure}

Esta es la parte realmente interesante de la transformación. En el bucle exterior, comenzamos en 1 (ya tenemos uno de los cuerpos del bucle, el original) y vamos hasta \textit{unrollFactor} iteraciones. Haciendo una copia del cuerpo del bucle por iteración conseguimos desenrollar el bucle con un factor de desenrollamiento de \textit{unrollFactor}.

Por cada iteración debemos pues hacer una copia del cuerpo del bucle. Las tres primeras instrucciones de este bucle externo lo que hacen es clonar la instrucción de incremento de índice, establecer su operando constante de incremento igual al número de iteración \textit{i} por el incremento constante paso de bucle original. Es decir, con esto conseguimos que si en cada iteración del bucle original el índice se incrementaba en 1 ahora en el cuerpo de desenrollamiento \textit{N} tendríamos un \textit{índice=indiceOriginal+N}, con lo que conseguimos el valor del índice correcto para esa iteración concreta. Deberemos sustituir los usos del índice por usos de la instrucción de incremento que acabamos de construir. De este modo si el bucle se incrementaba de uno en uno y había una expresión, por ejemplo \textit{a[i]}, ahora en el desenrollamiento \textit{N} esa expresión será sustituida por \textit{a[i+N]}.

Ya tenemos para este desenrollamiento calculada la expresión del índice en la instrucción add, debemos ahora copiar el cuerpo del bucle y sustituir las apariciones del índice por esta instrucción (ver líneas 6 a 32). En primer lugar existe un bucle para iterar sobre todos los bloques básicos que componen el cuerpo del bucle, del primero al último. Por cada uno de ellos el bloque se clona sobre la variable \textit{new\_hard\_work}. Si este bloque clonado inicia un nuevo cuerpo de bucle, debemos enlazar el unroll anterior con este (ver if líneas 9-12). Además se guarda en un mapa de la correspondencia entre bloques básicos originales y los recientemente clonados, más adelante veremos la utilidad de este mapa. Por último el bloque básico se inserta en la lista de bloques básicos después del iterador llamado \textit{last\_loop}, iterador en el que tenemos marcada en todo momento la posición a insertar nuevos bloques.

En este punto tenemos el bloque clonado e insertado, ahora debemos sustituir en él las apariciones del índice por la instrucción \textit{add} calculada anteriormente y que ya explicamos  (ver líneas 17 a 25). Simplemente se recorren todas las instrucciones del bloque básico y para cada una se recorren todos sus operandos, si alguno de esos operandos es el índice del bucle se sustituye por la instrucción \textit{add} ya explicada. Justo a continuación la instrucción \textit{add} se inserta al inicio del bloque si es que este es el primer bloque del cuerpo del bucle. Después simplemente se actualizan las variables \textit{last\_loop} y \textit{ant} para poder proceder con la siguiente iteración.

En principio, con esto, tendríamos ahora todo el bucle desenrollado tal y como queríamos.Sin embargo existe un problema no resuelto y es que al clonar un bloque básico, sus instrucciones que saltan a otros bloques básicos también se clonan tal cual. Esto es un problema, porque cada cuerpo de bucle debe hacer sus saltos a bloques de ese mismo cuerpo. Tal y como hemos clonado los bloques, todos los bloques clonados tendrán exactamente los mismos saltos que el cuerpo de bucle original, y eso no es correcto, ya que cada cuerpo de bucle debe reproducir el comportamiento del cuerpo original de forma completamente independiente. Para solucionar este problema usamos la variable \textit{remap\_map} que mapea bloques básicos originales a bloques básicos fruto de la clonación realizada. La solución es emplear este mapa para remapear los bloques destino de saltos en los bloques clonados a su destino correcto. Veamos como se realiza en el código de la figura ~\ref{FIG:LoopUnrollRemap}.

\begin{figure}[tph]
\begin{lstlisting}
//NOW REMAP ALL BRANCHS IN CLONED BLOCKS TO KEEP THE FLOW CONTROL CORRECT
for(iplist<BasicBlock>::iterator it=first_work;&*it<=last_work;it++)
{
	act=it;
	Term = cast<BranchInst>(llvmHelper::getTerminator(act));
	if((Term)&&
	(llvmHelper::getTerminator(act)->getOpcode()==Instruction::Br))
	{
	  for(j=0;j<llvmHelper::getNumSuccesors(Term);j++)
	  {
	    operand=dyn_cast<BasicBlock>(llvmHelper::getSuccessor(Term,j));
		//IF WE HAVE A REMAP RULE FOR THIS OPERAND LETS REMAP IT
	  	if(remap_map.find(operand)!=remap_map.end())
		{
			successor=remap_map.find(operand)->second;
			if(successor!=llvmHelper::getLoopLatch(_L)){
				llvmHelper::setSuccessor(Term,j,successor);
			}
		}
	  }
	}
}

}
//END OF THE EXTERNAL LOOP
//link the last unroll with the finish latch (FOR INCREMENT)
llvmHelper::setSuccessor(llvmHelper::getTerminator(ant)
	,0,llvmHelper::getLoopLatch(_L));
...
\end{lstlisting}
\caption{Desenrollamiento de bucles, Remapeado del CFG de los bloques clonados}
\label{FIG:LoopUnrollRemap}
\end{figure}

Este bucle de remmaping de los destinos de salto va desde el primer bloque clonado para este unrolling hasta el último. Para cada uno de estos bloques se obtiene su \textit{Terminator} (Última instrucción del bloque que ha de ser una instrucción de salto para enlazar al bloque con sus sucesores), y en el Terminator obtenido se realiza el remapeo de los destinos de salto empleando la variable \textit{remap\_map} (ver líneas 6 a 20).

Finalizado el unrolling, con los bucles clonados y establecidos los destinos de salto correctamente, observemos ahora la salida del bucle más externo, indicado por el comentario de la linea 25, que tenemos una instrucción que lo que hace es enlazar el último bloque que nos haya quedado en el cuerpo del bucle, con el bloque latch original que realiza el incremento del índice del bucle, de esta manera garantizamos que nuestro bucle sigue estando bien formado, el último de los unrollings se enlaza al incremento del índice del bucle.

Así pues en este punto tenemos todo el unrolling realizado, solo nos falta una pequeña cuestión y es que habiendo desenrollado el bucle debemos ahora modificar el incremento de la variable índice del mismo para que se incremente de N en N si es que N es nuestro factor de desenrollamiento. Podemos ver el código que realiza este trabajo en la figura ~\ref{FIG:LoopUnrollIndex} .

\begin{figure}[t]
\begin{lstlisting}
//Now change the cost increment of the loop acording to the unrolling factor
llvm::Constant * to_add=(llvm::Constant)(_unroll_factor*constant_inc);
llvmHelper::setNumOperand(add_inc,operand_cte,to_add);
//LOOP UNROLL END
}
\end{lstlisting}
\caption{Desenrollamiento de bucles, Modificación del incremento del índice}
\label{FIG:LoopUnrollIndex}
\end{figure}

En la variable \textit{to\_add} tenemos el cálculo de cuanto debemos incrementar el índice, \textit{add\_inc} es la instrucción de incremento del índice, y \textit{operand\_cte} es el número de operando donde debemos establecer el incremento.

Así pues, de esta manera tenemos el bucle desenrollado. Recapitulando muy brevemente sobre los pasos realizados lo que se ha hecho es:

\begin{itemize}
\item Iterar \textit{unrollFactor-1} veces para clonar el cuerpo del bucle las veces necesarias
\item Para cada iteración calcular el índice que corresponde a esa iteración como \textit{indice+(iteracion*pasoBucle)}
\item Clonar todos los bloques de cuerpo de bucle para la iteración actual (sustituyendo los usos del índice por el nuevo índice calculado) y remapear los bloques destino de saltos por el problema descrito anteriormente.
\item Finalizado el desenrollamiento, modificar la instrucción de incremento de índice de bucle en consonancia con el factor de desenrollamiento
\end{itemize}

De este modo se han implementado todos los pasos esenciales de una transformación de desenrollamiento de bucles, además de dar solución a problemas adicionales y otras cuestiones derivadas de la implementación.

\newpage
\subsection{Implementación del intercambio de bucles}

La transformación Loop Interchange se implementa en la clase \textit{LoopInterchangeTransform}. En esta transformación simplemente debemos modificar el CFG para intercambiar dos bucles que se encuentran en anidamiento perfecto, restricción impuesta en este proyecto fin de carrera. En la figura ~\ref{fig:LoopInterchangeBlocks} se muestra de forma gráfica el cambio en el CFG que debemos realizar.

%figura eclipse
\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{includes/images/loop_interchange.png}
\caption{CFG del Intercambio de bucles}
\label{fig:LoopInterchangeBlocks}
\end{figure}

El CFG de la izquierda representa los bucles antes de ser intercambiados y el de la derecha los representa después. Debemos observar que para intercambiar los bucles solo nos ha hecho falta cambiar los sucesores y predecesores de los bloques, es decir los arcos entre los bloques.

Veremos ahora en pseudo-código y sección a sección los métodos de \textit{LoopInterchangeTransform} necesarios para aplicar esta transformación.
El primero de ellos es el método \textit{ApplyInterchangeLoop\_check\_pre\_requisites} que comprueba que los bucles a intercambiar cumplen los requisitos necesarios que la transformación asume. Este método se muestra a continuación en la figura ~\ref{FIG:LoopInterchangeCheck}.


\begin{figure}[t]
\begin{lstlisting}
///checks the pre-requisites to safely apply the transform
bool LoopInterchangeTransform::ApplyInterchangeLoop_check_pre_requisites()
{
	//the loop must have 1 and only 1 child loop
	if(_L->getSubLoops().size()!=1)
	{
		return false;
	}
	Loop * subLoop=_L->getSubLoops().at(0);
	//the sub loop can not have any children
	if(subLoop->getSubLoops().size()!=0)
	{
		return false;
	}
	//loop and subloop must be perfectly nested
	if(!llvmHelper::arePerfectlyNestedLoops(_L,subLoop))
	{
		return false;
	}
	return true;
}
\end{lstlisting}
\caption{Intercambio de bucles, método de comprobación de los requisitos}
\label{FIG:LoopInterchangeCheck}
\end{figure}

El objeto Loop \textit{\_L} representa el bucle exterior. A través de un objeto bucle podemos recuperar sin problema sus bucles interiores, de modo que teniendo acceso al bucle externo tenemos cuanto necesitamos.
En el código presentado se comprueba que el bucle exterior tenga uno y solo uno bucles anidados, después se comprueba que el bucle interior no tenga a su vez bucles anidados. Esta condición es un poco fuerte y podría suprimirse. Solo se modificarán los mínimos bloques estrictamente necesarios del CFG por lo que no debería ser un problema sacarla.
Por último se comprueba que ambos bucles se encuentren en anidamiento perfecto.

Veamos ahora en las siguientes figuras el método transform que realiza finalmente la transformación de código, como en el caso del unrolling ya presentado, el intercambio de bucles comienza por comprobar los pre-requisitos, veámoslo en la figura ~\ref{FIG:LoopInterchangeTransformCheck}.

\begin{figure}[t]
\begin{lstlisting}
///Transforms the code applying a loop interchange
void LoopInterchangeTransform::transform()
{
  if(!ApplyInterchangeLoop_check_pre_requisites())
  {
    llvmHelper::xark_unreachable("LoopInterchangeTransform::transform()"
					"Loop Interchange pre-requisites fail");
  }
...
\end{lstlisting}
\caption{Intercambio de bucles, Comprobación de los requisitos}
\label{FIG:LoopInterchangeTransformCheck}
\end{figure}

Simplemente se llama a la función presentada anteriormente de comprobación de requisitos, si éstos no se cumplen se advierte del error.

Ahora veamos la primera fase de la transformación en la que se declaran e inicializan las variables necesarias, se muestra en la figura ~\ref{FIG:LoopInterchangeInit}.

\begin{figure}[t]
\begin{lstlisting}
vector <Loop*>sub_loops=_L->getSubLoops();
Loop* subLoop=sub_loops.at(0);
BasicBlock *outer_init=llvmHelper::getLoopPreHeader(_L);
BasicBlock *sub_init=llvmHelper::getLoopPreHeader(subLoop);
BasicBlock *sub_work=llvmHelper::getLoopFirstWork(subLoop,_LI);
BasicBlock *outer_head=llvmHelper::getLoopHeader(_L);
BasicBlock *sub_head=llvmHelper::getLoopHeader(subLoop);
BasicBlock *outer_latch=llvmHelper::getLoopLatch(_L);
BasicBlock *sub_latch=llvmHelper::getLoopLatch(subLoop);
BasicBlock *after_loops=llvmHelper::getLoopExit(_L);
llvm::Function * father=llvmHelper::getLoopFunction(_L);
BasicBlock *last_work=sub_latch->getPrevNode();
...
\end{lstlisting}
\caption{Intercambio de bucles, inicialización}
\label{FIG:LoopInterchangeInit}
\end{figure}

En esta parte del código se toman punteros a los bloques cruciales para poder realizar el intercambio de los bucles. Estos bloques indispensables para hacer el intercambio son los mismos que los que presentábamos en la figura ~\ref{fig:LoopInterchangeBlocks}. Además también se toma un puntero a la función que engloba a los dos bucles en la variable \textit{father}.

En la parte presentada a continuación lo que se hace es cambiar los arcos del CFG para reflejar la nueva situación fruto de aplicar el intercambio de los bucles, veámoslo en la figura ~\ref{FIG:LoopInterchangeModCFG}.

\begin{figure}[t]
\begin{lstlisting}
//SET THE CORRECT BRANCHES TO INTERCHANGE THE TWO LOOPS
llvmHelper::setSuccessor(llvmHelper::getTerminator(outer_init),0,sub_head);
llvmHelper::setSuccessor(llvmHelper::getTerminator(last_work),0,outer_latch);
llvmHelper::setSuccessor(llvmHelper::getTerminator(sub_head),1,after_loops);
llvmHelper::setSuccessor(llvmHelper::getTerminator(sub_head),0,sub_init);
llvmHelper::setSuccessor(llvmHelper::getTerminator(sub_init),0,outer_head);
llvmHelper::setSuccessor(llvmHelper::getTerminator(outer_head),0,sub_work);
llvmHelper::setSuccessor(llvmHelper::getTerminator(outer_head),1,sub_latch);
llvmHelper::setSuccessor(llvmHelper::getTerminator(outer_latch),0,outer_head);
llvmHelper::setSuccessor(llvmHelper::getTerminator(sub_latch),0,sub_head);
//NOW SORT THE BLOCKS IN THE FUNCTION LIST TO GET A CORRECT DUMP ORDER
llvmHelper::sortCode(father);
}
\end{lstlisting}
\caption{Intercambio de bucles, Modificación del CFG}
\label{FIG:LoopInterchangeModCFG}
\end{figure}

Como vemos, se cambian uno a uno los sucesores de lo bloques necesarios para intercambiar los bucles, se establece sucesor de la inicialización externa a la cabecera del bucle interno (ahora pasa a ser el externo), se establece la salida del cuerpo del bucle al \textit{latch} del bucle externo (ahora pasa a ser el interno), y así sucesivamente se establecen todos los arcos necesarios para intercambiar los bucles según se muestra en la figura ~\ref{fig:LoopInterchangeBlocks}.

Además de esta modificación del CFG se hace una última instrucción, se llama a la función \textit{sortCode} pasándole \textit{father} que es el objeto función que contiene a los bucles. Esta función \textit{SortCode} reordenará la lista de bloques para que el orden de los bloques sea el que se espera, es decir, que la nueva ordenación sea acorde con el nuevo CFG obtenido.
Esta reordenación es en principio completamente innecesaria, no obstante es bueno hacerla ya que puede haber código que la asuma en otras secciones del compilador.

La función de ordenación simplemente recorre el CFG a través de sus arcos y ordena los bloques según la relación de sucesor y predecesor que los arcos establecen.


\subsection{Implementación de la fisión de bucles}

La transformación de fisión de bucles a efectos de este proyecto se basa en dividir N computaciones independientes que se realizan en un mismo bucle, en N bucles equivalentes con una computación cada uno. Por ello se requiere un análisis de código para verificar que un bucle es potencialmente fisionable sin que la semántica del código cambie. No entraremos a explicar este análisis, sino la implementación de la transformación de fisión asumiendo que este análisis ha sido realizado en otra parte del traductor.

Como las demás transformaciones explicadas en secciones anteriores la transformación de fisión se implementa en un objeto subclase de \textit{CodeTransform}. Este objeto se llama \textit{LoopFisionTransform}, en su método \textit{transform} es donde se lleva a cabo la fisión.

Para explicar la fisión iremos presentando y explicando figuras de pseudo-códigos de los métodos más importantes en esta clase. El primero de ellos es el método \textit{ApplyFusionLoop\_check\_pre\_requisites} que comprueba que se cumplen todos los requisitos que nuestra implementación de la fisión asume, podemos ver este método en la figura ~\ref{FIG:LoopFisionCheckMethod}.

\begin{figure}[t]
\begin{lstlisting}
/**
 * checks the requisites for apply fision
 */
bool LoopFisionTransform::ApplyFusionLoop_check_pre_requisites()
{
	if(_L->getSubLoops().size()!=0)
	{
		return false;
	}
	return true;
}
\end{lstlisting}
\caption{Fisión de bucles, Método de Comprobación de los pre-requisitos}
\label{FIG:LoopFisionCheckMethod}
\end{figure}

Como podemos observar en este método solo se comprueba que el bucle al que aplicar fisión no contenga bucles internos.

En el método \textit{transform} la comprobación de los pre-requisitos es lo primero que se hace, como podemos ver en la figura ~\ref{FIG:LoopFisionCheck}.

\begin{figure}[t]
\begin{lstlisting}
/**
 * this will fision the loop
 */
void LoopFisionTransform::transform()
{

	if(!ApplyFusionLoop_check_pre_requisites())
	{
		llvmHelper::xark_unreachable("LoopFisionTransform::transform()"
						"check pre-requisites fail");
	}
...
\end{lstlisting}
\caption{Fisión de bucles, Comprobación de los pre-requisitos}
\label{FIG:LoopFisionCheck}
\end{figure}

Si los requisitos no se cumplen simplemente se informa mediante un error.
Si los requisitos se cumplen hemos de fisionar el bucle, en primer lugar hemos de tener un criterio por el cual hacer la fisión. El criterio mediante el cual fisionamos es separando núcleos computacionales o kernels que son independientes, estos kernels son objetos manejados por el analizador de código del módulo KIR gracias al cual se tiene el análisis necesario para hacer la paralelización. De aquí en adelante asumamos que en la variable kernels que presentamos en las próximas secciones de pseudo-código tenemos los \textit{kernels} de cómputo independientes asociados al cuerpo del bucle a fisionar.

Así pues veamos ahora en la figura ~\ref{FIG:LoopFisionClones} la primera sección de pseudo-código de la fisión.


\begin{figure}[t]
\begin{lstlisting}
vector<Loop*> all_loops;
all_loops.push_back(_L);
vector<BasicBlock*> loop_body=llvmHelper::getLoopBody(_L);
Instruction * loop_index=llvmHelper::getRealIndexPhiInst(_L);
DIKernel * ker,*ker_aux;	
//CLONE THE LOOP MANY TIMES
for(i=0;i<kernels.size()-1;i++)
{
	Loop * clone=new Loop();
	llvmHelper::cloneLoop(clone,_L,_LI);
	all_loops.push_back(clone);
}
if(all_loops.size()!=kernels.size())
{

	llvmHelper::xark_unreachable("LoopFisionTransform::transform()"
			"not same length loops and kernels");
}
\end{lstlisting}
\caption{Fisión de bucles, Clonación del bucle N veces}
\label{FIG:LoopFisionClones}
\end{figure}

En esta parte del código lo que se hace es clonar el bucle tantas veces como kernels independientes tengamos; de este modo, como resultado de este código tendremos \textit{N} bucles iguales al original si es que en el original había \textit{N kernels} independientes.
Observemos que insertamos todos los bucles en la lista \textit{all\_loops} y que después de clonar los bucles se comprueba que el número de bucles totales es igual al número de kernels independientes. Si no lo fuese es que algún error ha de haberse producido y se informa de ello.

La función de clonación de bucles \textit{CloneLoop} en la que nos apoyamos ha sido expresamente desarrollada para esta transformación. Simplemente dado un bucle genera en el código otro justo igual al original y situado justo a continuación de él. La implementación de esta función auxiliar no se incluye por no considerarse interesante, simplemente se apoya en la clonación de bloques básicos para clonar un bucle completo.

De esta manera tenemos todo preparado para realizar la fisión, ahora simplemente debemos en cada bucle borrar aquellas instrucciones que no pertenezcan al kernel de cómputo asignado para ese bucle, veámoslo en la figura ~\ref{FIG:LoopFisionSelErase}.

\begin{figure}[t]
\begin{lstlisting}
//Erase key instructions on the resultant loops
for(i=0;i<all_loops.size();i++){
	L=all_loops.at(i);
	ker=kernels.at(all_loops.size()-i-1);
	loop_body=llvmHelper::getLoopBody(L);
	count=0;
	for(j=0;j<loop_body.size();j++){
		bb=loop_body.at(j);
		for(BasicBlock::iterator Ib=bb->begin(),
			Eb=bb->end();Ib!=Eb;Ib++){
			I=Ib;
			ker_aux=inst_ker_map.find(count)->second;
			count++;
			if((ker_aux)&&
				(ker_aux!=ker)&&
				(ker_aux->getRoot()!=loop_index))
				{
					to_erase.push_back(I);
				}
			}
		}
	}
\end{lstlisting}
\caption{Fisión de bucles, Selección de las instrucciones a borrar}
\label{FIG:LoopFisionSelErase}
\end{figure}

Esta sección de código simplemente recorre todos los bucles. Para cada uno de ellos recorre su cuerpo de bucle en el que para cada bloque básico del cuerpo se recorren todas las instrucciones, y se marcan aquellas instrucciones que han de ser seleccionadas para ser borradas.
Una instrucción se marca para ser borrada cuando no pertenece al kernel de cómputo asignado al bucle actual y además no pertenece al kernel de cómputo del índice del bucle. Las instrucciones en dicho kernel nunca deben ser borradas para garantizar la correcta gestión del bucle.

En la linea 4 se asocia el kernel para el bucle siendo procesado, se hace en orden inverso de la lista para garantizar que el orden de evaluación de los kernels es igual a lo que el programador había especificado.

Observemos también que las instrucciones no se borran directamente sino que se marcan para ser borradas. Esto debe hacerse así porque los iteradores de LLVM son inseguros, es decir, si borraramos en ese punto las instrucciones se produciría un error en ejecución debido a inconsistencias en el iterador de instrucciones provocadas por el borrado de las mismas mientras son iteradas.

Así pues marcadas las instrucciones a ser borradas, la última tarea que falta es borrarlas definitivamente. Esto se hace en el código de la figura ~\ref{FIG:LoopFisionErase}.

\begin{figure}[t]
\begin{lstlisting}
//erase the to erase instructions
for(i=0;i<to_erase.size();i++)
{
	I=to_erase.at(i);
	I->dropAllReferences();
	I->removeFromParent();
	I->~Instruction();
}
\end{lstlisting}
\caption{Fisión de bucles, Borrado definitivo de las instrucciones}
\label{FIG:LoopFisionErase}
\end{figure}

Simplemente se recorren las instrucciones a borrar, para cada una se se llama a varios métodos para el borrado. El método \textit{dropAllReferences} borra todas las referencias que otras instrucciones tengan a esta, de este modo garantizamos un borrado seguro. El método \textit{removeFromParent} elimina la instrucción del bloque básico al que estuviera asociada y por último y muy importante se llama a \textit{\~~Instruction}, destructor de la clase instrucción que nos garantiza una adecuada liberación de la memoria.

De esta manera tenemos el bucle fisionado en \textit{N} bucles independientes, lo que puede ser usado para paralelizar códigos originalmente no paralelizables.


%\end{document} % Fin del documento